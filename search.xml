<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2F2017%2F06%2F06%2FTrie%2F</url>
    <content type="text"><![CDATA[In computer science, a trie, also called digital tree and sometimes radix tree or prefix tree, is a kind of search tree—an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. Basic features: Root does not contains characters, other nodes only contain one character. From root to node, catenate all the characters one by one in the path, the string is the value of the node. The node may not have value. Every node has different node. Advantages: Looking up data in a trie is faster in the worst case, O(m) time (where m is the length of a search string), compared to an imperfect hash table. There are no collisions of different keys in a trie. A trie can provide an alphabetical ordering of the entries by key. Drawbacks: Tries can be slower in some cases than hash tables for looking up data, especially if the data is directly accessed on a hard disk drive or some other secondary storage device where the random-access time is high compared to main memory. Some keys, such as floating point numbers, can lead to long chains and prefixes that are not particularly meaningful. Some tries can require more space than a hash table, as memory may be allocated for each character in the search string, rather than a single chunk of memory for the whole entry, as in most hash tables. Insert OperationFrom the root, track the tree by characters in the word until the tail of the word. Build new nodes if necessary. Update the value of node which contains the last character of the word. (in the chart below, the nodes which contains value are painted red) Find OperationSame as insert operation, track the tree by characters in the word until the tail of the word. If the tail cannot be reached or there is no value of on the last node, return false There is a problem on LeetCode solved by trie: 211. Add and Search Word - Data structure design Design a data structure that supports the following two operations:void addWord(word)bool search(word)search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Acutally, if you are familiar with trie. It is so easy and no need to explain the solution. Here is my solution.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WordDictionary &#123; private class trieNode &#123; public trieNode[] children = new trieNode[26]; public String item = ""; &#125; private trieNode root; /** Initialize your data structure here. */ public WordDictionary() &#123; root = new trieNode(); &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; trieNode node = root; for (char c : word.toCharArray()) &#123; if (node.children[c - 'a'] == null) node.children[c - 'a'] = new trieNode(); node = node.children[c - 'a']; &#125; node.item = word; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; return match(word.toCharArray(), 0, root); &#125; private boolean match(char[] word, int k, trieNode node) &#123; if (k == word.length) return !node.item.equals(""); if (word[k] != '.') &#123; return node.children[word[k] - 'a'] != null &amp;&amp; match(word, k + 1, node.children[word[k] - 'a']); &#125; else &#123; for (int i = 0; i &lt; node.children.length; i++) if (node.children[i] != null &amp;&amp; match(word, k + 1, node.children[i])) return true; &#125; return false; &#125;&#125;/** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Gap]]></title>
    <url>%2F2017%2F05%2F29%2Fmaximum-gap%2F</url>
    <content type="text"><![CDATA[Pigeonhole principleIn mathematics, the pigeonhole principle states that if n items are put into m containers, with n &gt; m &gt; 0, then at least one container must contain more than one item. Bucket sort is a generalization of pigeonhole sort. It works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the most to least significant digit flavour. Bucket sort works as follows: Set up an array of initially empty “buckets”. Scatter: Go over the original array, putting each object in its bucket. Sort each non-empty bucket. Gather: Visit the buckets in order and put all elements back into the original array. Leetcode 164 Maximum Gap is a problem using bucket sort. Given an unsorted array, find the maximum difference between the successive elements in its sorted form.Try to solve it in linear time/space.Return 0 if the array contains less than 2 elements.You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. The straightforward solution is quicksort the array and then find the gap, but quicksort consumes O(NlogN) time. It reuqires O(N) time and O(N) space. That is a basic feature of bucket sort, so I choose Bucket Sort as the method. In this question, bucket sort contains several steps: 1.Find the bucket sizeThe easiest way to set the bucket size as 1. If the requirement is to sort and return the array, it is the fastest way (although consumes extra large space). In this question, set the bucket size as 1 will exceed time limit. So the 1st thing to do is to find the bucket size.123456789// get the max and min value of the arrayint min = num[0];int max = num[0];for (int i:num) &#123; min = Math.min(min, i); max = Math.max(max, i);&#125;// the minimum possibale gap, ceiling of the integer divisionint gap = (int)Math.ceil((double)(max - min)/(num.length - 1)); Suppose there are N elements in the array, the min value is min and the max value is max. Then the maximum gap will be no smaller than gap = ceiling((max - min) / (N - 1)). Set the bucket size to gap, that can promise the max gap is between two numbers in two different buckets rather than in the same bucket. 2.Put the numbers in buckets1234567891011int[] bucketsMIN = new int[num.length]; // store the min value in that bucketint[] bucketsMAX = new int[num.length]; // store the max value in that bucket// put numbers into bucketsfor (int i:num) &#123; if (i == min || i == max) continue; int idx = (i - min) / gap; // index of the right position in the buckets bucketsMIN[idx] = Math.min(i, bucketsMin[idx]); bucketsMAX[idx] = Math.max(i, bucketsMax[idx]);&#125; In every bucket, the array bucketsMin and bucketsMax saves the min and max elements in every bucket. The max gap is between two adjacent buckets and maxgap = bucketsMAX[i] - bucketsMIN[i-1]. 3.find the max gap12345678910111213// scan the buckets for the max gapint maxGap = Integer.MIN_VALUE;int previous = min;for (int i = 0; i &lt; num.length; i++) &#123; if (bucketsMin[i] == Integer.MAX_VALUE) // empty bucket continue; // min value minus the previous value is the current gap maxGap = Math.max(maxGap, bucketsMin[i] - previous); // update previous bucket value previous = bucketsMax[i];&#125; the completed solution is following:12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int maximumGap(int[] nums) &#123; if (nums == null || nums.length &lt; 2) return 0; int min = nums[0], max = nums[0]; for (int num : nums) &#123; min = Math.min(min, num); max = Math.max(max, num); &#125; if(max == min) return 0; int gap = (int)Math.ceil((double)(max - min) / (nums.length - 1)); int[] bucketsMin = new int[nums.length]; int[] bucketsMax = new int[nums.length]; Arrays.fill(bucketsMin, Integer.MAX_VALUE); Arrays.fill(bucketsMax, Integer.MIN_VALUE); for (int i : nums) &#123; int idx = (i - min) / gap; bucketsMin[idx] = Math.min(i, bucketsMin[idx]); bucketsMax[idx] = Math.max(i, bucketsMax[idx]); &#125; int maxgap = 0; int previous = min; for (int i = 0; i &lt; nums.length; i++) &#123; if(bucketsMin[i] == Integer.MAX_VALUE) continue; maxgap = Math.max(maxgap, bucketsMin[i] - previous); previous = bucketsMax[i]; &#125; return maxgap; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dutch National Flag]]></title>
    <url>%2F2017%2F05%2F24%2FDutch-National-Flag%2F</url>
    <content type="text"><![CDATA[Dijkstra used the Dutch National Flag Problem as a structured programming exercise in program derivation and program proof. Given N objects coloured red, white or blue, sort them so that objects of the same colour are adjacent, with the colours in the order red, white and blue. Similar Problem on LeetCode : 75. Sort ColorsGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem.click to show follow up. Follow up:A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.Could you come up with an one-pass algorithm using only constant space? 1. Two-pass solution based on bucket sortObviously, this is a sort problem and it only contains 3 kinds of elements: red, white and blue, which reminds me of bucket sort. Use 3 integers to record the number of 3 colors in the 1st pass, then sort the array in the second pass. 123456789101112131415public class Solution &#123; public void sortColors(int[] A) &#123; int numRed = 0, numWhite = 0, numBlue = 0; for (int i = 0; i &lt; A.length; i++) &#123; if (A[i] == 0) numRed++; else if (A[i] == 1) numWhite++; else numBlue++; &#125; for (int i = 0; i &lt; A.length; i++) &#123; if (i &lt; numRed) A[i] = 0; else if (i &lt; numRed + numWhite) A[i] = 1; else A[i] = 2; &#125; &#125; &#125; 2. One-pass solution with 2 pointers in two waysAs follow-up requires, two-pass solution is not efficient enough. There should be one way to find elements and sort array at the same time. swap is used in this solution. Use two pointers end0 and head2 to record the end of 0 and the head of 2 during the process, respectively. At the beginning, end0 = 0, head2 = n - 1, where n is the length of array; When traverse all the elements, if it is 0, swap it with end0; If it is ‘2’, swap it with head2. Attention: if the element is 2, you cannot just swap it with head2 and go on, it may possible that the element at head2 is 0, so it is important to do extra check before moving on. On the contrary, the swap with end0 do not need extra check because element at end0 is sorted.12345678910111213141516171819public class Solution &#123; public void sortColors(int[] nums) &#123; int n = nums.length; int end0 = 0, head2 = n - 1, i = 0; while(i &lt;= head2) &#123; if(nums[i] == 0) swap(nums, end0++, i++); else if(nums[i] == 2) swap(nums, head2--, i); else i++; &#125; &#125; private void swap(int[] nums, int i1, int i2) &#123; int tmp = nums[i1]; nums[i1] = nums[i2]; nums[i2] = tmp; &#125;&#125; 3. One-pass solution with 3 pointers in one wayThere is one more easy way to solve this problem. The pointers only move in one way, and no swap is needed. All 3 pointers start from the head of array, record the end of 0,1,2.123456789101112131415161718public class Solution&#123; public void sortColors(int A[], int n) &#123; int n0 = -1, n1 = -1, n2 = -1; for (int i = 0; i &lt; n; ++i) &#123; if (A[i] == 0) &#123; A[++n2] = 2; A[++n1] = 1; A[++n0] = 0; &#125; else if (A[i] == 1) &#123; A[++n2] = 2; A[++n1] = 1; &#125; else if (A[i] == 2) &#123; A[++n2] = 2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2 and NodeJS, the practical guide: Introduction]]></title>
    <url>%2F2017%2F05%2F20%2FAngular-2-and-NodeJS-the-practical-guide-Introduction%2F</url>
    <content type="text"><![CDATA[1. NodeJSNodeJS is a server-side language based on JavaScript. Its function likes PHP, Ruby. Its function includes handle requests parse data generate &amp; send responses file operations One of the most popular framework of NodeJS is Express, an superset to NodeJS, which includes many common test to make you focus on the core things. 2. Angular 2Angular 2 is running on Browser, provides reactive experience. No need for send request and wait for response, every thing of Angular 2 happens instantly. Angular 2 is a superset to javascript.Angular 2 has some figures:1.Single page It runs one single page and updates parts of the page which need updating 2.Updates DOMIt updates the DOM to read render parts of the page which need to be updated 3.Handles routing of visual partsit will not use server for the routing. Instead, every thing works at the front end to load things faster. 4.Very reactive user experience 3. How NodeJS and Angular 2 work together When using a server-side only application, the client do not need to do any thing, just get the resource from the server. But obviously, every change of the page should have a request to server, and take which slow down the reaction of the application. Single page application can do the rendering on the client, server just need to send data to client and client will do the rendering and generate the page itself. 4. Setting up project Go to nodejs.org to download and install the latest version nodejs Open the NodeJS project and use terminal to navigate to the project folder. Use npm install to install the dependencies. Use npm run build, and keep it running, when something updated, it can update it in real time Open a new terminal ‘npm start’ to start the project, use web server to visit localhost:3000 to see the web.]]></content>
      <categories>
        <category>Full Stack</category>
      </categories>
      <tags>
        <tag>front end</tag>
        <tag>Angular 2</tag>
        <tag>NodeJS</tag>
        <tag>Udemy</tag>
        <tag>full stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Princeton Algorithm I: Elementary Symbol Tables]]></title>
    <url>%2F2017%2F05%2F19%2FPrinceton-Algorithm-I-Elementary-Symbol-Tables%2F</url>
    <content type="text"><![CDATA[1. API-What is the meaning of symbol tables?-Associate values to each key. To be more specific, to implements Key-Value pair abstraction. Key-Value pair abstraction Insert a value with specified key Given a key, search for the corresbonding value Ex. DNS lookup Insert URL with specified IP address Given URL, find corresponding IP address Some conventions Values are not null Method get() returns null if the key not present Method put() overwrites old value with new valuea Equality testAll Java classes inherit a method equals. To design equals, some standard recipe are following: Optimization for reference equality Check against null Check that to objects are of the same type and cast Compare each significant field: if field is a primitive type, use == if field is an object, use object.equals() if field is an array, apply to each entry (or Arrays.equals(a,b) but not a.equals(b)) Ex. Input a file, contains many words, output the word with max freqency123456789101112131415161718192021public class FrequencyCounter&#123; public static void main(String[] args) &#123; int minlen = Integer.parseInt(args[0]); ST&lt;String, Integer&gt; st = new ST&lt;String,Integer&gt;(); while (!StdIn.isEmpty()) &#123; //read the string and update freqency String word = StdIn.readString(); if (word.length() &lt; minlen) continue; //ignore short strings if (!st.contains(word)) st.put(word, 1); else st.put(word, st.get(word) + 1); &#125; String max = ""; st.put(max, 0); for (String word : st.keys()) if (st.get(word) &gt; st.get(max)) max = word; StdOut.println(max + " " + st.get(max)); //Print the string with max freq &#125;&#125; 2. Elementary ST implementation2.1 Sequential search in a linked listData structureMaintain an (unordered) linked list of key-value pairs.SearchScan through all keys until find a match.InsertScan through all keys until find a match; if no match add to front. 2.2 Binary Search in an ordered arrayData structureMaintain an ordered array of key-value pairs.SearchBinary SearchInsertNeed to shift all greater keys over. Important function for binary search: How many keys &lt; k ? 12345678910111213141516171819202122public Value get(Key key)&#123; if (isEmpty()) return null; int i = rank(key); if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) return vals[i]; else return null;&#125;//return the number of keys &lt; kprivate int rank(Key key)&#123; int lo = 0, hi = N-1; while (lo &lt;= hi) //Binary search &#123; int mid = lo + (hi - lo) / 2; int cmp = key.compareTo(keys[mid]); if (cmp &lt; 0) hi = mid - 1; else if (cmp &gt; 0) lo = mid + 1; else if (cmp == 0) return mid; &#125; return lo; &#125; The Summary of two ways is listed Obveresly, these two ways are not efficient enough, some optimization is still needed. Which will be discussed next. 3. Ordered OperationNormally, Ordered symbol table should have the following API 123456789101112131415161718192021public class ST&lt;Key extends Comparable&lt;Key&gt;, Value&gt;&#123; ST(); // create an ordered symbol table void put(Key key, Value val); //put key-value pair into the table (remove key from table if value is null) Value get(Key key); //value paired with key (null if key is absent) void delete(Key key); //remove key (and its value) from table boolean contains(Key key); //is there a value paired with key? boolean isEmpty(); //is the table empty? int size(); //number of key-value pairs Key min(); //smallest key Key max(); //largest key Key floor(Key key); //largest key less than or equal to key Key ceiling(Key key); //smallest key greater than or equal to key int rank(Key key); //number of keys less than key Key select(int k); //key of rank k void deleteMin(); //delete smallest key void deleteMax(); //delete largest key int size(Key lo, Key hi); //number of keys in [lo..hi] Iterable&lt;Key&gt; keys(Key lo, Key hi); //keys in [lo..hi], in sorted order Iterable&lt;Key&gt; keys(); //all keys in the table, in sorted order&#125;]]></content>
      <categories>
        <category>Princeton Algorithm I</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>princeton</tag>
        <tag>open course</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[New Blog, New Life]]></title>
    <url>%2F2017%2F05%2F15%2FNew-Blog-New-Life%2F</url>
    <content type="text"><![CDATA[HELLO THERE,This is my blog, posted on my own github.I created it by Hexo. Many themes tried, and Next is selected. Why I build this blog?I build this blog intending to write something for my coding life. I just followed a web course about algorithm and found that it was so inefficient to work out algorithm problems without discussion. I should make some conclusion on it to intensify the memory of these knowledge. At the same time, this blog can help me to : save my junk writing English learn about how to use my new Macbook Pro learn about how to use git to manage my project learn about Markdown, a language to write blog, which I am using to type this word What will I do on this blog? Conclusions about algorithm, problem oriented Some of my projects details Maybe some diary? Maybe some thoughts on movies, series or music A request to whom read this blogWell…… I am a little bit LAZY. So if you find that there is long time after the last article, please kindly remind me to write something. In the endAs all the coders do at the beginng… Hello World!]]></content>
      <categories>
        <category>My Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>