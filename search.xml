<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[KMP String matching Algorithm]]></title>
    <url>%2F2017%2F11%2F19%2FKMP-String-matching-Algorithm%2F</url>
    <content type="text"><![CDATA[1. Knuth-Morris-Pratt Pattern Matching AlgorithmThis algorithm is mostly used to find whether one string is a substring of another string. Suppose their lengths are M and N, The efficiency of Brute Force solution is O(MN) time and O(1) space. With KMP, the efficieny can archive O(M+N) time, and O(N) space. 1. Build the ‘next’ arrayThe core of KMP algorithm is to build a next array that next[i] used to store the length of suffix where the substring ends at the position i and has the same suffix and prefix. an example:| Index |0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|—|—|—|—|—|| Char |a|c|a|c|a|b|a|c|a|c|a|b|a|c|a|c|a|c|| Next |0|0|1|2|3|0|1|2|3|4|5|6|7|8|9|10|11|4 2. Match two stringsUsing the similar way above, compare two strings. There is a good video to show the process of KMP:https://www.youtube.com/watch?v=GTJr8OvyEVQ 2. Java Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.*;import java.util.Arrays;class Solution&#123; public static int[] buildNext(String s) &#123; //next[i] saves the max length of prefix that suffix equals prefix and // this substring ends with position i char[] chars = s.toCharArray(); int[] next = new int[s.length()]; int i = 1, j = 0; while (i &lt; chars.length) &#123; if (chars[i] == chars[j]) &#123; next[i] = j + 1; j++; i++; &#125; else &#123; if (j == 0) &#123; next[i] = 0; i++; &#125; else &#123; j = next[j - 1]; &#125; &#125; &#125; return next; &#125; public static boolean KMP(String s, String p) &#123; int[] next = buildNext(s); int i = 0, j = 0; while (i &lt; s.length() &amp;&amp; j &lt; p.length()) &#123; if (s.charAt(i) == p.charAt(j)) &#123; i++; j++; &#125; else &#123; if (j == 0) &#123; i++; &#125; else &#123; j = next[j - 1]; &#125; &#125; &#125; if (j == p.length()) return true; else return false; &#125; public static void main (String[] args) throws java.lang.Exception&#123; boolean result = KMP("abcdabcdabcd", "dabcd"); System.out.println(result); &#125;&#125; 3. Shortest Repeating Substring Given a string s, return its shortest repeating substring’s lengthEx.Input: abcdabcdabcdOutput: 4 (abcd) This problem can be solved using the next array. The answer is s.length() - next[next.length - 1] Index 0 1 2 3 4 5 6 7 8 9 10 11 Char a b c d a b c d a b c d Next 0 0 0 0 1 2 3 4 5 6 7 8 1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;class Solution &#123; public static int[] buildNext(String s) &#123; //next[i] saves the max length of prefix that suffix equals prefix and // this substring ends with position i char[] chars = s.toCharArray(); int[] next = new int[s.length()]; int i = 1, j = 0; while (i &lt; chars.length) &#123; if (chars[i] == chars[j]) &#123; next[i] = j + 1; j++; i++; &#125; else &#123; if (j == 0) &#123; next[i] = 0; i++; &#125; else &#123; j = next[j - 1]; &#125; &#125; &#125; return next; &#125; public static int findShortestRepeatedSubstringLength(String s) &#123; int[] next = buildNext(s); return s.length() - next[next.length - 1]; &#125; public static void main (String[] args) throws java.lang.Exception&#123; int result = findShortestRepeatedSubstringLength("abcdabcdabcd"); System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>string</tag>
        <tag>shortest repeating substring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interval Manipulation && Characters Counting Problems]]></title>
    <url>%2F2017%2F07%2F31%2FInterval-Manipulation-Characters-Counting-Problems%2F</url>
    <content type="text"><![CDATA[This article concludes 8 problems in 2 topics. Interval Manipulation Character/String Counting with Hash 1. Missing Interval Given a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges. ExampleGiven nums = [0, 1, 3, 50, 75], lower = 0 and upper = 99return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”]. Similar ProblemsLintCode 30, LeetCode 163 This is a simple simulation. Deal with the intervals at head and tail separatedly, and deal with the intervals in the middle iteratively. Pay attention to Integer.MAX_VALUE and Integer.MIN_VALUE, transfer the number to long or deal with these 2 situations separatedly. Use function to make a clear code style. 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; /** * @param nums a sorted integer array * @param lower an integer * @param upper an integer * @return a list of its missing ranges */ public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123; // Write your code here List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (nums.length == 0) &#123; addRange(ans, lower, upper); return ans; &#125; addRange(ans, lower, (long) nums[0] - 1); for (int i = 1; i &lt; nums.length; i++) &#123; addRange(ans, (long) nums[i - 1] + 1, (long) nums[i] - 1); &#125; addRange(ans, (long) nums[nums.length - 1] + 1, upper); return ans; &#125; void addRange(List&lt;String&gt; ans, long st, long ed) &#123; if (st &gt; ed) &#123; return; &#125; else if (st == ed) &#123; ans.add(st + ""); return; &#125; else ans.add(st + "-&gt;" + ed); &#125;&#125; 2. Merge Intervals Given a collection of intervals, merge all overlapping intervals. Example[ [ [1, 3], [1, 6], [2, 6], =&gt; [8, 10], [8, 10], [15, 18] [15, 18] ]] Similar ProblemsLintCode 156, LeetCode 56 Easy and simple, sort the intervals by start point, ascending order, then merge the intervals from left to right one-by-one if possible. The time complexity is O(nlogn), which caused by sort. 123456789101112131415161718192021222324252627class Solution &#123; /** * @param intervals, a collection of intervals * @return: A new sorted interval list. */ public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; // write your code here List&lt;Interval&gt; ans = new ArrayList&lt;&gt;(); Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; public int compare(Interval obj0, Interval obj1) &#123; return obj0.start - obj1.start; &#125; &#125;); Interval last = null; for (Interval item : intervals) &#123; if (last == null || last.end &lt; item.start) &#123; ans.add(item); last = item; &#125; else &#123; last.end = Math.max(last.end, item.end); // Modify the element already in list &#125; &#125; return ans; &#125;&#125; 3. Insert interval Given a non-overlapping interval list which is sorted by start point. Insert a new interval into it, make sure the list is still in order and non-overlapping (merge intervals if necessary). ExampleInsert [2, 5] into [[1,2], [5,9]], we get [[1,9]]. Insert [3, 4] into [[1,2], [5,9]], we get [[1,2], [3,4], [5,9]]. Similar ProblemsLintCode 30, LeetCode 57 Insert the interval first, then deal with it as Merge Interval. The other way is to classify the intervals in 3 kinds: smaller than the new one, need to be merged with new one, and larger than the new one. 1234567891011121314151617181920212223242526public class Solution &#123; public ArrayList&lt;Interval&gt; insert(ArrayList&lt;Interval&gt; intervals, Interval newInterval) &#123; if (newInterval == null || intervals == null) &#123; return intervals; &#125; ArrayList&lt;Interval&gt; results = new ArrayList&lt;Interval&gt;(); int insertPos = 0; for (Interval interval : intervals) &#123; if (interval.end &lt; newInterval.start) &#123; results.add(interval); insertPos++; &#125; else if (interval.start &gt; newInterval.end) &#123; results.add(interval); &#125; else &#123; newInterval.start = Math.min(interval.start, newInterval.start); newInterval.end = Math.max(interval.end, newInterval.end); &#125; &#125; results.add(insertPos, newInterval); return results; &#125;&#125; 4. First Position Unique Character Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. ExampleGiven s = &quot;lintcode&quot;, return 0.Given s = &quot;lovelintcode&quot;, return 2. Similar ProblemsLintCode 646, LeetCode 387 Note that if building a character hash table, it is more efficent to use int[256] rather than HashTable, according to ASCII contains 256 characters. 123456789101112131415161718192021public class Solution &#123; /** * @param s a string * @return it's index */ public int firstUniqChar(String s) &#123; // Write your code here int[] cnt = new int[256]; for (char c : s.toCharArray()) &#123; cnt[c]++; &#125; for (int i = 0; i &lt; s.length(); i++) &#123; if (cnt[s.charAt(i)] == 1) &#123; return i; &#125; &#125; return -1; &#125;&#125; 5. Substring Anagrams Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 40,000. The order of output does not matter. ExampleThe substring with start index = 0 is “cba”, which is an anagram of “abc”.The substring with start index = 6 is “bac”, which is an anagram of “abc”. Similar ProblemsLintCode 647, LeetCode 438 If two strings contains same numbers of same characters, ignore order, these two strings are the anagram of each other. The brute force solution is find all the substrings of s which length is s.length() and check whether they are anagrams of p. The time complexity is O(mn) where m,n is the length of s, p. Brute force solution will cause TLE. Realizing that the neighboring substring has only 1-character-difference.It is possible to hold an int[256] to count the difference of current substring and p, and update it by add a new character on the right and delete the left old character. The time complexity is O(n). 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; // Write your code here List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (s.length() &lt; p.length()) &#123; return ans; &#125; char[] sc = s.toCharArray(); char[] pc = p.toCharArray(); int[] det = new int[256]; for (int i = 0; i &lt; p.length(); i++) &#123; det[pc[i]]--; det[sc[i]]++; &#125; int absSum = 0; for (int item : det) &#123; absSum += Math.abs(item); &#125; if (absSum == 0) &#123; ans.add(0); &#125; for (int i = p.length(); i &lt; s.length(); i++) &#123; int r = sc[i]; int l = sc[i - p.length()]; absSum = absSum - Math.abs(det[r]) - Math.abs(det[l]); det[r]++; det[l]--; absSum = absSum + Math.abs(det[r]) + Math.abs(det[l]); if (absSum == 0) &#123; ans.add(i - p.length() + 1); &#125; &#125; return ans; &#125;&#125; 6. Word Abbreviation Set An abbreviation of a word follows the form . Below are some examples of word abbreviations:123456789101112a) it --&gt; it (no abbreviation) 1b) d|o|g --&gt; d1g 1 1 1 1---5----0----5--8c) i|nternationalizatio|n --&gt; i18n 1 1---5----0d) l|ocalizatio|n --&gt; l10n Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word’s abbreviation is unique if no other word from the dictionary has the same abbreviation. ExampleGiven dictionary = [ &quot;deer&quot;, &quot;door&quot;, &quot;cake&quot;, &quot;card&quot; ]isUnique(“dear”) // return falseisUnique(“cart”) // return trueisUnique(“cane”) // return falseisUnique(“make”) // return true Similar ProblemsLintCode 648, LeetCode 288 Although this problem does not require complex algorithms, it still need some work to extact the solution. Solution 1: count the times words and abbrs appear and find rules the times the word appears in the dicationary == the times the word abbreviation appears in the abbr dictionary ===&gt; Unique else ===&gt; Not Unique Use 2 maps to keep the word dictionary and abbr dictionary and every word and abbr appearing times. 1234567891011121314151617181920212223242526272829303132333435363738public class ValidWordAbbr &#123; Map&lt;String, Integer&gt; dict = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; abbr = new HashMap&lt;&gt;(); // @param dictionary a list of word public ValidWordAbbr(String[] dictionary) &#123; // Write your code here for (String d : dictionary) &#123; if (!dict.containsKey(d)) &#123; dict.put(d, 1); &#125; else &#123; dict.put(d, dict.get(d) + 1); &#125; String a = getAbbr(d); if (!abbr.containsKey(a)) &#123; abbr.put(a, 1); &#125; else &#123; abbr.put(a, abbr.get(a) + 1); &#125; &#125; &#125; /** * @param word a string * @return true if its abbreviation is unique or false */ public boolean isUnique(String word) &#123; // Write your code here String a = getAbbr(word); return dict.get(word) == abbr.get(a); &#125; String getAbbr(String str) &#123; if (str.length() &lt;= 2) &#123; return str; &#125; return "" + str.charAt(0) + (str.length() - 2) + str.charAt(str.length() - 1); &#125; Solution 2: abbr keep its original wordsUse 1 map Map&lt;String, Set&lt;String&gt;&gt;, store original words in the set every abbr maps to, so that when finding a word is unique, check the set. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ValidWordAbbr &#123; private Map&lt;String,Set&lt;String&gt;&gt; d; // @param dictionary a list of word public ValidWordAbbr(String[] dictionary) &#123; // Write your code here d = new HashMap&lt;String, Set&lt;String&gt;&gt;(); for (int i = 0;i &lt; dictionary.length; i++) &#123; String w = dictionary[i]; String abbr = getAbbr(w); if (d.containsKey(abbr)) &#123; Set&lt;String&gt; s = d.get(abbr); if (!s.contains(w)) s.add(w); &#125; else &#123; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); s.add(w); d.put(abbr,s); &#125; &#125; &#125; /** * @param word a string * @return true if its abbreviation is unique or false */ public boolean isUnique(String word) &#123; // Write your code here String a = getAbbr(word); if (d.containsKey(a)) &#123; Set&lt;String&gt; s = d.get(a); if (s.size() == 1 &amp;&amp; s.contains(word)) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; private String getAbbr(String w)&#123; int len = w.length() - 2; if (len &lt;= 0) &#123; return w; &#125; return "" + w.charAt(0) + len + w.charAt(w.length() - 1); &#125;&#125; 7. Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. ExampleGiven [100, 4, 200, 1, 3, 2],The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. Similar ProblemsLintCode 124, LeetCode 128 Brute force solution is to sort the array, and find the consectutive sequence from left to right, which time complexity is O(nlogn). There is an O(n) solution. Every consecutive sequence is like a collection. if one element belongs to this collection, then any other collection must not contain it. Keep a set to record the elements, while one element is visited, remove it. Because every element is visited for one time. The time complexity is O(n). 123456789101112131415161718192021222324252627282930313233public class Solution &#123; /** * @param nums: A list of integers * @return an integer */ public int longestConsecutive(int[] num) &#123; // write you code here Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int item : num) &#123; set.add(item); &#125; int ans = 0; for (int item : num) &#123; if (set.contains(item)) &#123; set.remove(item); int pre = item - 1; int next = item + 1; while (set.contains(pre)) &#123; set.remove(pre); pre--; &#125; while (set.contains(next)) &#123; set.remove(next); next++; &#125; ans = Math.max(ans, next - pre - 1); &#125; &#125; return ans; &#125;&#125; 8. Longest Increasing Subsequence Given a sequence of integers, find the longest increasing subsequence (LIS).You code should return the length of the LIS. ExampleFor [5, 4, 1, 2, 3], the LIS is [1, 2, 3], return 3For [4, 2, 4, 5, 3, 7], the LIS is [2, 4, 5, 7], return 4 Similar ProblemsLintCode 76, LeetCode 300 Solution 1： Dynamic Processingdp[i] is the longest increasing subsequence that end with the ith element.State transition equation : dp[i] = max(dp[k]) + 1.dp[k] meets : 0 &lt;= k &lt; i &amp;&amp; nums[k] &lt; nums[i] The time compexity is O(n^2). 123456789101112131415161718192021public class Solution &#123; public int longestIncreasingSubsequence(int[] nums) &#123; if(nums.length == 0)&#123; return 0; &#125; int[] lis = new int[nums.length]; int max = 0; for (int i = 0; i &lt; nums.length; i++)&#123; int localMax = 0; // find the longest increasing subsequence that end with ith element for (int j = 0; j &lt; i; j++)&#123; if (lis[j] &gt; localMax &amp;&amp; nums[j] &lt;= nums[i])&#123; localMax = lis[j]; &#125; &#125; lis[i] = localMax + 1; max = Math.max(max, lis[i]); &#125; return max; &#125;&#125; Solution 2: Keep every possible sequenceTake [1,3,5,2,8,4,6....] as example. When 6 is visited, there are 4 Different length The end of the sequence is the minimum one in sequences with same lengthsequences. 11,21,3,41,3,5,6 These sequences may be LIS. When a new number nums[i] is coming, update these sequences with following rules. If nums[i] is larger than all these sequences tails, a new sequence with larger length should be added. Copy the longest sequence and add nums[i] as the new sequence. If nums[i] is smaller than all these sequeces tails, update the sequence with length 1 Else update the sequence’s tail whose tail just larger than nums[i]. Find this sequence by Binary Search 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public int longestIncreasingSubsequence(int[] nums) &#123; // write your code here if(nums.length == 0)&#123; return 0; &#125; int len = 0; int[] tails = new int[nums.length]; tails[0] = nums[0]; for(int i = 1; i &lt; nums.length; i++)&#123; if(nums[i] &lt; tails[0])&#123; tails[0] = nums[i]; &#125; else if (nums[i] &gt; tails[len])&#123; tails[++len] = nums[i]; &#125; else &#123; tails[binarySearch(tails, 0, len, nums[i])] = nums[i]; &#125; &#125; return len + 1; &#125; private int binarySearch(int[] tails, int min, int max, int target)&#123; while(min &lt;= max)&#123; int mid = min + (max - min) / 2; if(tails[mid] == target)&#123; return mid; &#125; if(tails[mid] &lt; target)&#123; min = mid + 1; &#125; if(tails[mid] &gt; target)&#123; max = mid - 1; &#125; &#125; return min; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simulation Algorithms && String Manipulation Skills]]></title>
    <url>%2F2017%2F07%2F23%2Fsimulation-algorithms-string-manipulation-skills%2F</url>
    <content type="text"><![CDATA[1. Sliding Window Average from Data Stream Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Input exampleMovingAverage m = new MovingAverage(3);m.next(1) = 1 // return 1.00000m.next(10) = (1 + 10) / 2 // return 5.50000m.next(3) = (1 + 10 + 3) / 3 // return 4.66667m.next(5) = (10 + 3 + 5) / 3 // return 6.00000 Similar QuestionsLintCode 642, LeetCode 346 Solution 1. Prefix Sum IAs the following chart shows, a is an array, and s is a‘s Prefix Sum array. s[i] = a[1] + a[2] + a[3] …. + a[i] index 0 1 2 3 4 5 6 7 a 3 4 11 1 -4 2 3 s 0 3 7 18 19 15 17 20 With prefix sum, it is easy to find the sum of any consecutive elements. a[k] + a[k + 1] +... + a[j] = s[j] - s[k -1]. 123456789101112131415161718192021222324public class MovingAverage &#123; /** * Initialize your data structure here. */ double[] sum; int id, size; MovingAverage(int size) &#123; sum = new double[1000000]; //this is not final version id = 0; this.size = size; &#125; public double next(int val) &#123; // Write your code here id++; sum[id] = sum[id - 1] + val; if (id - size &gt;= 0) &#123; return (sum[id] - sum[id - size]) / size; &#125; else &#123; return sum[id] / id; &#125; &#125;&#125; The time complexity is O(1), but space complexity is O(n). As the quantity of data is unknown, this solution is not workable. Solution 2. Prefix Sum II : Rolling ArrayIn this problem, if the prefix sum has been recorded, the data before the sliding window is useless. This enlight me to improve the array as rolling array.Use size == 3 as example,|Original Location|0|1|2|3|4|5|6|7||:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:||Rolling Location|0|1|2|3|0|1|2|3|When the window moves to 4, the result is s[4] - s[1]. At this time, s[0] will never be used, so s[4] can be saved at s[0]. Rolling Location == Original Location mod (size + 1) 1234567891011121314151617181920212223242526272829public class MovingAverage &#123; /** * Initialize your data structure here. */ double[] sum; int id, size; MovingAverage(int size) &#123; sum = new double[size + 1]; id = 0; this.size = size; &#125; int mod(int x) &#123; return x % (size + 1); &#125; public double next(int val) &#123; // Write your code here id++; sum[mod(id)] = sum[mod(id - 1)] + val; if (id - size &gt;= 0) &#123; return (sum[mod(id)] - sum[mod(id - size)]) / size; &#125; else &#123; return sum[mod(id)] / id; &#125; &#125;&#125; The time complexity is O(1), and space complexity is O(size + 1). Solution 3. Queue / LinkedlistWith no doubt, data stream is like a queue, build a queue is a straightforward and easy way to solve this problem. 12345678910111213141516171819202122public class MovingAverage &#123; private Queue&lt;Integer&gt; que; private double sum = 0; private int size; /** Initialize your data structure here. */ public MovingAverage(int size) &#123; que = new LinkedList&lt;Integer&gt;(); this.size = size; &#125; public double next(int val) &#123; // Write your code here sum += val; if (que.size() == size) &#123; sum = sum - que.poll(); &#125; que.offer(val); return sum / que.size(); &#125;&#125; 2. Edit Distance II Given two strings S and T, determine if they are both one edit distance apart.Example(s)Given s = “aDb”, t = “adb”return trueSimilar ProblemsLintCode 640, LeetCode 161 What is one edit distance?if with only one-character edition(insertion, deletion or substitution), the string s equals the string t, then s and t are with one edit distance. From the definition above, the solution is obvious. There are 3 kinds of editions, so it can be solved by classification. 1. s.length() == t.length(), substitution2. s.length() == t.length + 1, deletion3. s.length() == t.length - 1, insertion 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; /** * @param s a string * @param t a string * @return true if they are both one edit distance apart or false */ public boolean isOneEditDistance(String s, String t) &#123; // Write your code here if (s.length() &gt; t.length()) &#123; return isOneEditDistance(t, s); &#125; int diff = t.length() - s.length(); if (diff &gt; 1) &#123; return false; &#125; if (diff == 0) &#123; int cnt = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (t.charAt(i) != s.charAt(i)) &#123; cnt++; &#125; &#125; return (cnt == 1); &#125; if (diff == 1) &#123; for (int i = 0; i &lt; s.length(); i++) &#123; if (t.charAt(i) != s.charAt(i)) &#123; return (s.substring(i).equals(t.substring(i + 1))); &#125; &#125; &#125; return true; &#125;&#125; 3. Read Characters From File - multiple calls The API: int read4(char *buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file. Note:The read function will only be called once for each test case. This is a system operation simulation problem. It is similar to reading data from disk. RAM is a buffer. The function read4() likes reading data from disk to RAM, which is slow. The function read() likes reading data from RAM. The buffer is built with a Queue. This buffer has the following characteristics. 1. FIFO, which promises the order of data2. When the buffer is empty, call read4 to enqueue3. When the buffer is not empty and read is called, dequeue and put the elements into buffer. 1234567891011121314151617181920212223242526public class Solution extends Reader4 &#123; /** * @param buf destination buffer * @param n maximum number of characters to read * @return the number of characters read */ char[] buffer = new char[4]; int head = 0, tail = 0; public int read(char[] buf, int n) &#123; int i = 0; while (i &lt; n) &#123; if (head == tail) &#123; // queue is empty head = 0; tail = read4(buffer); // enqueue if (tail == 0) &#123; break; &#125; &#125; while (i &lt; n &amp;&amp; head &lt; tail) &#123; buf[i++] = buffer[head++]; // dequeue &#125; &#125; return i; &#125;&#125; 4. Strings Serialization Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Please implement encode and decode ExamplesGiven strs = [“lint”,”code”,”love”,”you”]string encoded_string = encode(strs) return `[“lint”,”code”,”love”,”you”]｀ when you call decode(encoded_string) Similar ProblemsLintCode 659, LeetCode 271 In function encode, concatenate strings with the length of the following string. To seperate the length and the string, add / between them in order to prevent that string begins with a number and mixes with the length. 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; /** * @param strs a list of strings * @return encodes a list of strings to a single string. */ public String encode(List&lt;String&gt; strs) &#123; String res = ""; for (String s : strs) &#123; res = res + s.length() + '/' + s; &#125; return res; &#125; /** * @param str a string * @return dcodes a single string to a list of strings */ public List&lt;String&gt; decode(String str) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int i = 0, n = str.length(); while (i &lt; n) &#123; int num = 0; while (str.charAt(i) != '/') &#123; num = num * 10 + (str.charAt(i) - '0'); i++; &#125; i++; if (i + num == n) res.add(str.substring(i)); else res.add(str.substring(i, i + num)); i = i + num; &#125; return res; &#125;&#125; 5. System Longest File Path Suppose we abstract our file system by a string in the following manner:The string &quot;dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext&quot; represents:1234dir subdir1 subdir2 file.ext The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.The string &quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot; represents:1234567dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is &quot;dir/subdir2/subsubdir2/file2.ext&quot;, and its length is 32 (not including the double quotes).Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Notes The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a .. Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. Similar ProblemsLintCode 643, LeetCode 388 This problem seems really complex, this input string make me confused at first. But it is easy to read and operate after using split(&#39;\n&#39;). Use split(&#39;/n&#39;) to split the input string, after that the string can be operated line by line Count the number of &#39;\t&#39; to judge the level of current dir or file. Basic DFS problem.12345678910111213141516171819202122232425public class Solution &#123; /* * @param input an abstract file system * @return return the length of the longest absolute path to file */ public int lengthLongestPath(String input) &#123; // Write your code here if (input.length() == 0) &#123; return 0; &#125; int ans = 0; int[] level_size = new int[input.length() + 1]; for (String line : input.split("\n")) &#123; int level = line.lastIndexOf('\t') + 2; int len = line.length() - (level - 1); if (line.contains(".")) &#123; ans = Math.max(ans, level_size[level - 1] + len); &#125; else &#123; level_size[level] = level_size[level - 1] + len + 1; &#125; &#125; return ans; &#125;&#125; 6. Roman to Integer Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Similar ProblemsLintCode 419, LeetCode 13 Roman numeral• 1~9: {“I”, “II”, “III”, “IV”, “V”, “VI”, “VII”, “VIII”, “IX”};• 10~90: {“X”, “XX”, “XXX”, “XL”, “L”, “LX”, “LXX”, “LXXX”, “XC”};• 100~900: {“C”, “CC”, “CCC”, “CD”, “D”, “DC”, “DCC”, “DCCC”, “CM”};• 1000~3000: {“M”, “MM”, “MMM”}. The characteristics of Roman numeral must be extracted. At most times, just add all the numeral from left to right. only 4, 9, 40, 90... need to consider subtraction. Other than these numbers, Roman numerals decrease from left to right. So if there is a Roman numeral smaller than its right one, then it should be subtracted. 1234567891011121314151617181920212223242526272829303132public class Solution &#123; /** * @param s Roman representation * @return an integer */ public int romanToInt(String s) &#123; // Write your code here int ans; char[] sc = s.toCharArray(); ans = toInt(sc[0]); //0 special for (int i = 1; i &lt; s.length(); i++) &#123; ans += toInt(sc[i]); if (toInt(sc[i - 1]) &lt; toInt(sc[i])) &#123; ans -= toInt(sc[i - 1]) * 2; &#125; &#125; return ans; &#125; int toInt(char s) &#123; switch(s) &#123; case 'I':return 1; case 'V':return 5; case 'X':return 10; case 'L':return 50; case 'C':return 100; case 'D':return 500; case 'M':return 1000; &#125; return 0; &#125;&#125; 7. Integer to Roman Given an integer, convert it to a roman numeral.Input is guaranteed to be within the range from 1 to 3999. Similar ProblemsLintCode 419, LeetCode 13 Firstly build the dictionary, then seperate the digital and transfer it digit by digit. The normal solution of digital seperation is to use % and /. 1234567891011121314public class Solution &#123; /** * @param n The integer * @return Roman representation */ public String intToRoman(int n) &#123; // Write your code here String M[] = &#123;"", "M", "MM", "MMM"&#125;; String C[] = &#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; String X[] = &#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;; String I[] = &#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; return M[n / 1000] + C[(n / 100) % 10] + X[(n / 10) % 10] + I[n % 10]; &#125;&#125; 8. Identify Celebrity Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them. Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: “Hi, A. Do you know B?” to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense). You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows. Similar ProblemsLintCode 645, LeetCode 277 Solution 1: Brute ForceUsing knows(a, b) for each people with each people. The time complexity is O(n^2). Solution 2Every time knows(a, b) is called, one people is out. if true then a is not celebrity, else b is not celebrity. At the end, use another iteration to test the whether the last person is celebrity or there is no one.The time complexity is O(n).1234567891011121314151617181920212223242526public class Solution extends Relation &#123; /** * @param n a party with n people * @return the celebrity's label or -1 */ public int findCelebrity(int n) &#123; // Write your code here int candidate = 0; for(int i = 1; i &lt; n; i++) &#123; if (knows(candidate, i)) &#123; candidate = i; &#125; &#125; for(int i = 0; i &lt; candidate; i++) &#123; if(knows(candidate, i) || !knows(i, candidate)) &#123; return -1; &#125; &#125; for(int i = candidate + 1; i &lt; n; i++) &#123; if(!knows(i, candidate)) &#123; return -1; &#125; &#125; return candidate; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>string</tag>
        <tag>simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert Sorted List to Binary Search Tree]]></title>
    <url>%2F2017%2F06%2F22%2FConvert-Sorted-List-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[109. Convert Sorted List to Binary Search TreeGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. This is a classical algorithm problem. But it requires deep understanding of binary search, tree traversal and linked list. The output of BST in-order traversal is an ascending-order array. So the template of in-order traversal can help to build this BST. The basic codes of in-order rebuilding of balanced BST is123456789101112private TreeNode inOrder (int begin, int end)&#123; if (begin &gt; end) return null; TreeNode node； int mid = begin + (end - begin) / 2; TreeNode left = inOrder(begin, mid - 1); TreeNode node = new TreeNode(nums[mid]); node.left = left; TreeNode right = inOrder(mid + 1, end); node.right = right; return node;&#125; It is easy to deal with with a sorted array. But in this problem, it is rebulit from linked list. There are several ways to deal with it. These solutions are similar: find a way to realize some features of arrays to linked list, then use the classical way which rebuild a BST from array, to rebuild it from linked list. 1. Find the middle value from beginning every timeIt is the simplest way, but not efficient.Use 2 pointers to find the middle value. One is faster, which moves 2 steps every time; one is slower, moves 1 step every time. When the faster pointer reaches the end, the slower one just reach the middle of the linked list. 12345678910111213141516171819202122232425public class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; return toBST(head,null); &#125; public TreeNode toBST(ListNode head, ListNode tail) &#123; ListNode slow = head; ListNode fast = head; if(head==tail) return null; while(fast!=tail&amp;&amp;fast.next!=tail) &#123; fast = fast.next.next; slow = slow.next; &#125; //slow is the middle node of linked list TreeNode node = new TreeNode(slow.val); node.left = toBST(head,slow); node.right = toBST(slow.next,tail); return node; &#125;&#125; 2. Using in-order traversal template, binary search likeUse a global variable node to store the visiting postion of linked list. 1234567891011121314151617181920212223242526272829303132333435public class Solution&#123; private ListNode node; public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; int size = 0; ListNode runner = head; node = head; //size finds the total number of nodes of linked list while(runner != null) &#123; runner = runner.next; size ++; &#125; return inorderHelper(0, size - 1); &#125; public TreeNode inorderHelper(int start, int end) &#123; if(start &gt; end) return null; int mid = start + (end - start) / 2; TreeNode left = inorderHelper(start, mid - 1); TreeNode treenode = new TreeNode(node.val); treenode.left = left; node = node.next; TreeNode right = inorderHelper(mid + 1, end); treenode.right = right; return treenode; &#125;&#125; 2. Using in-order traversal template, simplerUpper two ways in reality using the feature of BST, which likes binary search. These two ways’ code looks similar to binary search template. There is another way using the template. 123456789101112131415161718192021222324252627public class Solution &#123; ListNode listNode; private TreeNode treeBuilder(int n) &#123; if (n == 0) return null; TreeNode treeNode = new TreeNode(0); treeNode.left = treeBuilder(n / 2); treeNode.val = listNode.val; listNode = listNode.next; treeNode.right = treeBuilder(n - n / 2 - 1); return treeNode; &#125; public TreeNode sortedListToBST(ListNode head) &#123; if (head == null) return null; int size = 1; ListNode curr = head; while (curr.next != null) &#123; size++; curr = curr.next; &#125; listNode = head; return treeBuilder(size); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>tree</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2F2017%2F06%2F06%2FTrie%2F</url>
    <content type="text"><![CDATA[In computer science, a trie, also called digital tree and sometimes radix tree or prefix tree, is a kind of search tree—an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. Basic features: Root does not contains characters, other nodes only contain one character. From root to node, catenate all the characters one by one in the path, the string is the value of the node. The node may not have value. Every node has different node. Advantages: Looking up data in a trie is faster in the worst case, O(m) time (where m is the length of a search string), compared to an imperfect hash table. There are no collisions of different keys in a trie. A trie can provide an alphabetical ordering of the entries by key. Drawbacks: Tries can be slower in some cases than hash tables for looking up data, especially if the data is directly accessed on a hard disk drive or some other secondary storage device where the random-access time is high compared to main memory. Some keys, such as floating point numbers, can lead to long chains and prefixes that are not particularly meaningful. Some tries can require more space than a hash table, as memory may be allocated for each character in the search string, rather than a single chunk of memory for the whole entry, as in most hash tables. Insert OperationFrom the root, track the tree by characters in the word until the tail of the word. Build new nodes if necessary. Update the value of node which contains the last character of the word. (in the chart below, the nodes which contains value are painted red) Find OperationSame as insert operation, track the tree by characters in the word until the tail of the word. If the tail cannot be reached or there is no value of on the last node, return false There is a problem on LeetCode solved by trie: 211. Add and Search Word - Data structure design Design a data structure that supports the following two operations:void addWord(word)bool search(word)search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Acutally, if you are familiar with trie. It is so easy and no need to explain the solution. Here is my solution.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WordDictionary &#123; private class trieNode &#123; public trieNode[] children = new trieNode[26]; public String item = ""; &#125; private trieNode root; /** Initialize your data structure here. */ public WordDictionary() &#123; root = new trieNode(); &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; trieNode node = root; for (char c : word.toCharArray()) &#123; if (node.children[c - 'a'] == null) node.children[c - 'a'] = new trieNode(); node = node.children[c - 'a']; &#125; node.item = word; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; return match(word.toCharArray(), 0, root); &#125; private boolean match(char[] word, int k, trieNode node) &#123; if (k == word.length) return !node.item.equals(""); if (word[k] != '.') &#123; return node.children[word[k] - 'a'] != null &amp;&amp; match(word, k + 1, node.children[word[k] - 'a']); &#125; else &#123; for (int i = 0; i &lt; node.children.length; i++) if (node.children[i] != null &amp;&amp; match(word, k + 1, node.children[i])) return true; &#125; return false; &#125;&#125;/** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Gap]]></title>
    <url>%2F2017%2F05%2F29%2Fmaximum-gap%2F</url>
    <content type="text"><![CDATA[Pigeonhole principleIn mathematics, the pigeonhole principle states that if n items are put into m containers, with n &gt; m &gt; 0, then at least one container must contain more than one item. Bucket sort is a generalization of pigeonhole sort. It works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the most to least significant digit flavour. Bucket sort works as follows: Set up an array of initially empty “buckets”. Scatter: Go over the original array, putting each object in its bucket. Sort each non-empty bucket. Gather: Visit the buckets in order and put all elements back into the original array. Leetcode 164 Maximum Gap is a problem using bucket sort. Given an unsorted array, find the maximum difference between the successive elements in its sorted form.Try to solve it in linear time/space.Return 0 if the array contains less than 2 elements.You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. The straightforward solution is quicksort the array and then find the gap, but quicksort consumes O(NlogN) time. It reuqires O(N) time and O(N) space. That is a basic feature of bucket sort, so I choose Bucket Sort as the method. In this question, bucket sort contains several steps: 1.Find the bucket sizeThe easiest way to set the bucket size as 1. If the requirement is to sort and return the array, it is the fastest way (although consumes extra large space). In this question, set the bucket size as 1 will exceed time limit. So the 1st thing to do is to find the bucket size.123456789// get the max and min value of the arrayint min = num[0];int max = num[0];for (int i:num) &#123; min = Math.min(min, i); max = Math.max(max, i);&#125;// the minimum possibale gap, ceiling of the integer divisionint gap = (int)Math.ceil((double)(max - min)/(num.length - 1)); Suppose there are N elements in the array, the min value is min and the max value is max. Then the maximum gap will be no smaller than gap = ceiling((max - min) / (N - 1)). Set the bucket size to gap, that can promise the max gap is between two numbers in two different buckets rather than in the same bucket. 2.Put the numbers in buckets1234567891011int[] bucketsMIN = new int[num.length]; // store the min value in that bucketint[] bucketsMAX = new int[num.length]; // store the max value in that bucket// put numbers into bucketsfor (int i:num) &#123; if (i == min || i == max) continue; int idx = (i - min) / gap; // index of the right position in the buckets bucketsMIN[idx] = Math.min(i, bucketsMin[idx]); bucketsMAX[idx] = Math.max(i, bucketsMax[idx]);&#125; In every bucket, the array bucketsMin and bucketsMax saves the min and max elements in every bucket. The max gap is between two adjacent buckets and maxgap = bucketsMAX[i] - bucketsMIN[i-1]. 3.find the max gap12345678910111213// scan the buckets for the max gapint maxGap = Integer.MIN_VALUE;int previous = min;for (int i = 0; i &lt; num.length; i++) &#123; if (bucketsMin[i] == Integer.MAX_VALUE) // empty bucket continue; // min value minus the previous value is the current gap maxGap = Math.max(maxGap, bucketsMin[i] - previous); // update previous bucket value previous = bucketsMax[i];&#125; the completed solution is following:12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int maximumGap(int[] nums) &#123; if (nums == null || nums.length &lt; 2) return 0; int min = nums[0], max = nums[0]; for (int num : nums) &#123; min = Math.min(min, num); max = Math.max(max, num); &#125; if(max == min) return 0; int gap = (int)Math.ceil((double)(max - min) / (nums.length - 1)); int[] bucketsMin = new int[nums.length]; int[] bucketsMax = new int[nums.length]; Arrays.fill(bucketsMin, Integer.MAX_VALUE); Arrays.fill(bucketsMax, Integer.MIN_VALUE); for (int i : nums) &#123; int idx = (i - min) / gap; bucketsMin[idx] = Math.min(i, bucketsMin[idx]); bucketsMax[idx] = Math.max(i, bucketsMax[idx]); &#125; int maxgap = 0; int previous = min; for (int i = 0; i &lt; nums.length; i++) &#123; if(bucketsMin[i] == Integer.MAX_VALUE) continue; maxgap = Math.max(maxgap, bucketsMin[i] - previous); previous = bucketsMax[i]; &#125; return maxgap; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dutch National Flag]]></title>
    <url>%2F2017%2F05%2F24%2FDutch-National-Flag%2F</url>
    <content type="text"><![CDATA[Dijkstra used the Dutch National Flag Problem as a structured programming exercise in program derivation and program proof. Given N objects coloured red, white or blue, sort them so that objects of the same colour are adjacent, with the colours in the order red, white and blue. Similar Problem on LeetCode : 75. Sort ColorsGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem.click to show follow up. Follow up:A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.Could you come up with an one-pass algorithm using only constant space? 1. Two-pass solution based on bucket sortObviously, this is a sort problem and it only contains 3 kinds of elements: red, white and blue, which reminds me of bucket sort. Use 3 integers to record the number of 3 colors in the 1st pass, then sort the array in the second pass. 123456789101112131415public class Solution &#123; public void sortColors(int[] A) &#123; int numRed = 0, numWhite = 0, numBlue = 0; for (int i = 0; i &lt; A.length; i++) &#123; if (A[i] == 0) numRed++; else if (A[i] == 1) numWhite++; else numBlue++; &#125; for (int i = 0; i &lt; A.length; i++) &#123; if (i &lt; numRed) A[i] = 0; else if (i &lt; numRed + numWhite) A[i] = 1; else A[i] = 2; &#125; &#125; &#125; 2. One-pass solution with 2 pointers in two waysAs follow-up requires, two-pass solution is not efficient enough. There should be one way to find elements and sort array at the same time. swap is used in this solution. Use two pointers end0 and head2 to record the end of 0 and the head of 2 during the process, respectively. At the beginning, end0 = 0, head2 = n - 1, where n is the length of array; When traverse all the elements, if it is 0, swap it with end0; If it is ‘2’, swap it with head2. Attention: if the element is 2, you cannot just swap it with head2 and go on, it may possible that the element at head2 is 0, so it is important to do extra check before moving on. On the contrary, the swap with end0 do not need extra check because element at end0 is sorted.12345678910111213141516171819public class Solution &#123; public void sortColors(int[] nums) &#123; int n = nums.length; int end0 = 0, head2 = n - 1, i = 0; while(i &lt;= head2) &#123; if(nums[i] == 0) swap(nums, end0++, i++); else if(nums[i] == 2) swap(nums, head2--, i); else i++; &#125; &#125; private void swap(int[] nums, int i1, int i2) &#123; int tmp = nums[i1]; nums[i1] = nums[i2]; nums[i2] = tmp; &#125;&#125; 3. One-pass solution with 3 pointers in one wayThere is one more easy way to solve this problem. The pointers only move in one way, and no swap is needed. All 3 pointers start from the head of array, record the end of 0,1,2.123456789101112131415161718public class Solution&#123; public void sortColors(int A[], int n) &#123; int n0 = -1, n1 = -1, n2 = -1; for (int i = 0; i &lt; n; ++i) &#123; if (A[i] == 0) &#123; A[++n2] = 2; A[++n1] = 1; A[++n0] = 0; &#125; else if (A[i] == 1) &#123; A[++n2] = 2; A[++n1] = 1; &#125; else if (A[i] == 2) &#123; A[++n2] = 2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Princeton Algorithm I: Elementary Symbol Tables]]></title>
    <url>%2F2017%2F05%2F19%2FPrinceton-Algorithm-I-Elementary-Symbol-Tables%2F</url>
    <content type="text"><![CDATA[1. API-What is the meaning of symbol tables?-Associate values to each key. To be more specific, to implements Key-Value pair abstraction. Key-Value pair abstraction Insert a value with specified key Given a key, search for the corresbonding value Ex. DNS lookup Insert URL with specified IP address Given URL, find corresponding IP address Some conventions Values are not null Method get() returns null if the key not present Method put() overwrites old value with new valuea Equality testAll Java classes inherit a method equals. To design equals, some standard recipe are following: Optimization for reference equality Check against null Check that to objects are of the same type and cast Compare each significant field: if field is a primitive type, use == if field is an object, use object.equals() if field is an array, apply to each entry (or Arrays.equals(a,b) but not a.equals(b)) Ex. Input a file, contains many words, output the word with max freqency123456789101112131415161718192021public class FrequencyCounter&#123; public static void main(String[] args) &#123; int minlen = Integer.parseInt(args[0]); ST&lt;String, Integer&gt; st = new ST&lt;String,Integer&gt;(); while (!StdIn.isEmpty()) &#123; //read the string and update freqency String word = StdIn.readString(); if (word.length() &lt; minlen) continue; //ignore short strings if (!st.contains(word)) st.put(word, 1); else st.put(word, st.get(word) + 1); &#125; String max = ""; st.put(max, 0); for (String word : st.keys()) if (st.get(word) &gt; st.get(max)) max = word; StdOut.println(max + " " + st.get(max)); //Print the string with max freq &#125;&#125; 2. Elementary ST implementation2.1 Sequential search in a linked listData structureMaintain an (unordered) linked list of key-value pairs.SearchScan through all keys until find a match.InsertScan through all keys until find a match; if no match add to front. 2.2 Binary Search in an ordered arrayData structureMaintain an ordered array of key-value pairs.SearchBinary SearchInsertNeed to shift all greater keys over. Important function for binary search: How many keys &lt; k ? 12345678910111213141516171819202122public Value get(Key key)&#123; if (isEmpty()) return null; int i = rank(key); if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) return vals[i]; else return null;&#125;//return the number of keys &lt; kprivate int rank(Key key)&#123; int lo = 0, hi = N-1; while (lo &lt;= hi) //Binary search &#123; int mid = lo + (hi - lo) / 2; int cmp = key.compareTo(keys[mid]); if (cmp &lt; 0) hi = mid - 1; else if (cmp &gt; 0) lo = mid + 1; else if (cmp == 0) return mid; &#125; return lo; &#125; The Summary of two ways is listed Obveresly, these two ways are not efficient enough, some optimization is still needed. Which will be discussed next. 3. Ordered OperationNormally, Ordered symbol table should have the following API 123456789101112131415161718192021public class ST&lt;Key extends Comparable&lt;Key&gt;, Value&gt;&#123; ST(); // create an ordered symbol table void put(Key key, Value val); //put key-value pair into the table (remove key from table if value is null) Value get(Key key); //value paired with key (null if key is absent) void delete(Key key); //remove key (and its value) from table boolean contains(Key key); //is there a value paired with key? boolean isEmpty(); //is the table empty? int size(); //number of key-value pairs Key min(); //smallest key Key max(); //largest key Key floor(Key key); //largest key less than or equal to key Key ceiling(Key key); //smallest key greater than or equal to key int rank(Key key); //number of keys less than key Key select(int k); //key of rank k void deleteMin(); //delete smallest key void deleteMax(); //delete largest key int size(Key lo, Key hi); //number of keys in [lo..hi] Iterable&lt;Key&gt; keys(Key lo, Key hi); //keys in [lo..hi], in sorted order Iterable&lt;Key&gt; keys(); //all keys in the table, in sorted order&#125;]]></content>
      <categories>
        <category>Princeton Algorithm I</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>princeton</tag>
        <tag>open course</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[New Blog, New Life]]></title>
    <url>%2F2017%2F05%2F15%2FNew-Blog-New-Life%2F</url>
    <content type="text"><![CDATA[HELLO THERE,This is my blog, posted on my own github.I created it by Hexo. Many themes tried, and Next is selected. Why I build this blog?I build this blog intending to write something for my coding life. I just followed a web course about algorithm and found that it was so inefficient to work out algorithm problems without discussion. I should make some conclusion on it to intensify the memory of these knowledge. At the same time, this blog can help me to : save my junk writing English learn about how to use my new Macbook Pro learn about how to use git to manage my project learn about Markdown, a language to write blog, which I am using to type this word What will I do on this blog? Conclusions about algorithm, problem oriented Some of my projects details Maybe some diary? Maybe some thoughts on movies, series or music A request to whom read this blogWell…… I am a little bit LAZY. So if you find that there is long time after the last article, please kindly remind me to write something. In the endAs all the coders do at the beginng… Hello World!]]></content>
      <categories>
        <category>My Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>