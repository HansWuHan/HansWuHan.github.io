<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Simulation Algorithms && String Manipulation Skills]]></title>
    <url>%2F2017%2F07%2F23%2Fsimulation-algorithms-string-manipulation-skills%2F</url>
    <content type="text"><![CDATA[1. Sliding Window Average from Data Stream Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Input exampleMovingAverage m = new MovingAverage(3);m.next(1) = 1 // return 1.00000m.next(10) = (1 + 10) / 2 // return 5.50000m.next(3) = (1 + 10 + 3) / 3 // return 4.66667m.next(5) = (10 + 3 + 5) / 3 // return 6.00000 Similar QuestionsLintCode 642, LeetCode 346 Solution 1. Prefix Sum IAs the following chart shows, a is an array, and s is a‘s Prefix Sum array. s[i] = a[1] + a[2] + a[3] …. + a[i] index 0 1 2 3 4 5 6 7 a 3 4 11 1 -4 2 3 s 0 3 7 18 19 15 17 20 With prefix sum, it is easy to find the sum of any consecutive elements. a[k] + a[k + 1] +... + a[j] = s[j] - s[k -1]. 123456789101112131415161718192021222324public class MovingAverage &#123; /** * Initialize your data structure here. */ double[] sum; int id, size; MovingAverage(int size) &#123; sum = new double[1000000]; //this is not final version id = 0; this.size = size; &#125; public double next(int val) &#123; // Write your code here id++; sum[id] = sum[id - 1] + val; if (id - size &gt;= 0) &#123; return (sum[id] - sum[id - size]) / size; &#125; else &#123; return sum[id] / id; &#125; &#125;&#125; The time complexity is O(1), but space complexity is O(n). As the quantity of data is unknown, this solution is not workable. Solution 2. Prefix Sum II : Rolling ArrayIn this problem, if the prefix sum has been recorded, the data before the sliding window is useless. This enlight me to improve the array as rolling array.Use size == 3 as example,|Original Location|0|1|2|3|4|5|6|7||:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:||Rolling Location|0|1|2|3|0|1|2|3|When the window moves to 4, the result is s[4] - s[1]. At this time, s[0] will never be used, so s[4] can be saved at s[0]. Rolling Location == Original Location mod (size + 1) 1234567891011121314151617181920212223242526272829public class MovingAverage &#123; /** * Initialize your data structure here. */ double[] sum; int id, size; MovingAverage(int size) &#123; sum = new double[size + 1]; id = 0; this.size = size; &#125; int mod(int x) &#123; return x % (size + 1); &#125; public double next(int val) &#123; // Write your code here id++; sum[mod(id)] = sum[mod(id - 1)] + val; if (id - size &gt;= 0) &#123; return (sum[mod(id)] - sum[mod(id - size)]) / size; &#125; else &#123; return sum[mod(id)] / id; &#125; &#125;&#125; The time complexity is O(1), and space complexity is O(size + 1). Solution 3. Queue / LinkedlistWith no doubt, data stream is like a queue, build a queue is a straightforward and easy way to solve this problem. 12345678910111213141516171819202122public class MovingAverage &#123; private Queue&lt;Integer&gt; que; private double sum = 0; private int size; /** Initialize your data structure here. */ public MovingAverage(int size) &#123; que = new LinkedList&lt;Integer&gt;(); this.size = size; &#125; public double next(int val) &#123; // Write your code here sum += val; if (que.size() == size) &#123; sum = sum - que.poll(); &#125; que.offer(val); return sum / que.size(); &#125;&#125; 2. Edit Distance II Given two strings S and T, determine if they are both one edit distance apart.Example(s)Given s = “aDb”, t = “adb”return trueSimilar ProblemsLintCode 640, LeetCode 161 What is one edit distance?if with only one-character edition(insertion, deletion or substitution), the string s equals the string t, then s and t are with one edit distance. From the definition above, the solution is obvious. There are 3 kinds of editions, so it can be solved by classification. 1. s.length() == t.length(), substitution2. s.length() == t.length + 1, deletion3. s.length() == t.length - 1, insertion 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; /** * @param s a string * @param t a string * @return true if they are both one edit distance apart or false */ public boolean isOneEditDistance(String s, String t) &#123; // Write your code here if (s.length() &gt; t.length()) &#123; return isOneEditDistance(t, s); &#125; int diff = t.length() - s.length(); if (diff &gt; 1) &#123; return false; &#125; if (diff == 0) &#123; int cnt = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (t.charAt(i) != s.charAt(i)) &#123; cnt++; &#125; &#125; return (cnt == 1); &#125; if (diff == 1) &#123; for (int i = 0; i &lt; s.length(); i++) &#123; if (t.charAt(i) != s.charAt(i)) &#123; return (s.substring(i).equals(t.substring(i + 1))); &#125; &#125; &#125; return true; &#125;&#125; 3. Read Characters From File - multiple calls The API: int read4(char *buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file. Note:The read function will only be called once for each test case. This is a system operation simulation problem. It is similar to reading data from disk. RAM is a buffer. The function read4() likes reading data from disk to RAM, which is slow. The function read() likes reading data from RAM. The buffer is built with a Queue. This buffer has the following characteristics. 1. FIFO, which promises the order of data2. When the buffer is empty, call read4 to enqueue3. When the buffer is not empty and read is called, dequeue and put the elements into buffer. 1234567891011121314151617181920212223242526public class Solution extends Reader4 &#123; /** * @param buf destination buffer * @param n maximum number of characters to read * @return the number of characters read */ char[] buffer = new char[4]; int head = 0, tail = 0; public int read(char[] buf, int n) &#123; int i = 0; while (i &lt; n) &#123; if (head == tail) &#123; // queue is empty head = 0; tail = read4(buffer); // enqueue if (tail == 0) &#123; break; &#125; &#125; while (i &lt; n &amp;&amp; head &lt; tail) &#123; buf[i++] = buffer[head++]; // dequeue &#125; &#125; return i; &#125;&#125; 4. Strings Serialization Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Please implement encode and decode ExamplesGiven strs = [“lint”,”code”,”love”,”you”]string encoded_string = encode(strs) return `[“lint”,”code”,”love”,”you”]｀ when you call decode(encoded_string) Similar ProblemsLintCode 659, LeetCode 271 In function encode, concatenate strings with the length of the following string. To seperate the length and the string, add / between them in order to prevent that string begins with a number and mixes with the length. 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; /** * @param strs a list of strings * @return encodes a list of strings to a single string. */ public String encode(List&lt;String&gt; strs) &#123; String res = ""; for (String s : strs) &#123; res = res + s.length() + '/' + s; &#125; return res; &#125; /** * @param str a string * @return dcodes a single string to a list of strings */ public List&lt;String&gt; decode(String str) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int i = 0, n = str.length(); while (i &lt; n) &#123; int num = 0; while (str.charAt(i) != '/') &#123; num = num * 10 + (str.charAt(i) - '0'); i++; &#125; i++; if (i + num == n) res.add(str.substring(i)); else res.add(str.substring(i, i + num)); i = i + num; &#125; return res; &#125;&#125; 5. System Longest File Path Suppose we abstract our file system by a string in the following manner:The string &quot;dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext&quot; represents:1234dir subdir1 subdir2 file.ext The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.The string &quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot; represents:1234567dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is &quot;dir/subdir2/subsubdir2/file2.ext&quot;, and its length is 32 (not including the double quotes).Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Notes The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a .. Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. Similar ProblemsLintCode 643, LeetCode 388 This problem seems really complex, this input string make me confused at first. But it is easy to read and operate after using split(&#39;\n&#39;). Use split(&#39;/n&#39;) to split the input string, after that the string can be operated line by line Count the number of &#39;\t&#39; to judge the level of current dir or file. Basic DFS problem.12345678910111213141516171819202122232425public class Solution &#123; /* * @param input an abstract file system * @return return the length of the longest absolute path to file */ public int lengthLongestPath(String input) &#123; // Write your code here if (input.length() == 0) &#123; return 0; &#125; int ans = 0; int[] level_size = new int[input.length() + 1]; for (String line : input.split("\n")) &#123; int level = line.lastIndexOf('\t') + 2; int len = line.length() - (level - 1); if (line.contains(".")) &#123; ans = Math.max(ans, level_size[level - 1] + len); &#125; else &#123; level_size[level] = level_size[level - 1] + len + 1; &#125; &#125; return ans; &#125;&#125; 6. Roman to Integer Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Similar ProblemsLintCode 419, LeetCode 13 Roman numeral• 1~9: {“I”, “II”, “III”, “IV”, “V”, “VI”, “VII”, “VIII”, “IX”};• 10~90: {“X”, “XX”, “XXX”, “XL”, “L”, “LX”, “LXX”, “LXXX”, “XC”};• 100~900: {“C”, “CC”, “CCC”, “CD”, “D”, “DC”, “DCC”, “DCCC”, “CM”};• 1000~3000: {“M”, “MM”, “MMM”}. The characteristics of Roman numeral must be extracted. At most times, just add all the numeral from left to right. only 4, 9, 40, 90... need to consider subtraction. Other than these numbers, Roman numerals decrease from left to right. So if there is a Roman numeral smaller than its right one, then it should be subtracted. 1234567891011121314151617181920212223242526272829303132public class Solution &#123; /** * @param s Roman representation * @return an integer */ public int romanToInt(String s) &#123; // Write your code here int ans; char[] sc = s.toCharArray(); ans = toInt(sc[0]); //0 special for (int i = 1; i &lt; s.length(); i++) &#123; ans += toInt(sc[i]); if (toInt(sc[i - 1]) &lt; toInt(sc[i])) &#123; ans -= toInt(sc[i - 1]) * 2; &#125; &#125; return ans; &#125; int toInt(char s) &#123; switch(s) &#123; case 'I':return 1; case 'V':return 5; case 'X':return 10; case 'L':return 50; case 'C':return 100; case 'D':return 500; case 'M':return 1000; &#125; return 0; &#125;&#125; 7. Integer to Roman Given an integer, convert it to a roman numeral.Input is guaranteed to be within the range from 1 to 3999. Similar ProblemsLintCode 419, LeetCode 13 Firstly build the dictionary, then seperate the digital and transfer it digit by digit. The normal solution of digital seperation is to use % and /. 1234567891011121314public class Solution &#123; /** * @param n The integer * @return Roman representation */ public String intToRoman(int n) &#123; // Write your code here String M[] = &#123;"", "M", "MM", "MMM"&#125;; String C[] = &#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; String X[] = &#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;; String I[] = &#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; return M[n / 1000] + C[(n / 100) % 10] + X[(n / 10) % 10] + I[n % 10]; &#125;&#125; 8. Identify Celebrity Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them. Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: “Hi, A. Do you know B?” to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense). You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows. Similar ProblemsLintCode 645, LeetCode 277 Solution 1: Brute ForceUsing knows(a, b) for each people with each people. The time complexity is O(n^2). Solution 2Every time knows(a, b) is called, one people is out. if true then a is not celebrity, else b is not celebrity. At the end, use another iteration to test the whether the last person is celebrity or there is no one.The time complexity is O(n).1234567891011121314151617181920212223242526public class Solution extends Relation &#123; /** * @param n a party with n people * @return the celebrity's label or -1 */ public int findCelebrity(int n) &#123; // Write your code here int candidate = 0; for(int i = 1; i &lt; n; i++) &#123; if (knows(candidate, i)) &#123; candidate = i; &#125; &#125; for(int i = 0; i &lt; candidate; i++) &#123; if(knows(candidate, i) || !knows(i, candidate)) &#123; return -1; &#125; &#125; for(int i = candidate + 1; i &lt; n; i++) &#123; if(!knows(i, candidate)) &#123; return -1; &#125; &#125; return candidate; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>simulation</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert Sorted List to Binary Search Tree]]></title>
    <url>%2F2017%2F06%2F22%2FConvert-Sorted-List-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[109. Convert Sorted List to Binary Search TreeGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. This is a classical algorithm problem. But it requires deep understanding of binary search, tree traversal and linked list. The output of BST in-order traversal is an ascending-order array. So the template of in-order traversal can help to build this BST. The basic codes of in-order rebuilding of balanced BST is123456789101112private TreeNode inOrder (int begin, int end)&#123; if (begin &gt; end) return null; TreeNode node； int mid = begin + (end - begin) / 2; TreeNode left = inOrder(begin, mid - 1); TreeNode node = new TreeNode(nums[mid]); node.left = left; TreeNode right = inOrder(mid + 1, end); node.right = right; return node;&#125; It is easy to deal with with a sorted array. But in this problem, it is rebulit from linked list. There are several ways to deal with it. These solutions are similar: find a way to realize some features of arrays to linked list, then use the classical way which rebuild a BST from array, to rebuild it from linked list. 1. Find the middle value from beginning every timeIt is the simplest way, but not efficient.Use 2 pointers to find the middle value. One is faster, which moves 2 steps every time; one is slower, moves 1 step every time. When the faster pointer reaches the end, the slower one just reach the middle of the linked list. 12345678910111213141516171819202122232425public class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; return toBST(head,null); &#125; public TreeNode toBST(ListNode head, ListNode tail) &#123; ListNode slow = head; ListNode fast = head; if(head==tail) return null; while(fast!=tail&amp;&amp;fast.next!=tail) &#123; fast = fast.next.next; slow = slow.next; &#125; //slow is the middle node of linked list TreeNode node = new TreeNode(slow.val); node.left = toBST(head,slow); node.right = toBST(slow.next,tail); return node; &#125;&#125; 2. Using in-order traversal template, binary search likeUse a global variable node to store the visiting postion of linked list. 1234567891011121314151617181920212223242526272829303132333435public class Solution&#123; private ListNode node; public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; int size = 0; ListNode runner = head; node = head; //size finds the total number of nodes of linked list while(runner != null) &#123; runner = runner.next; size ++; &#125; return inorderHelper(0, size - 1); &#125; public TreeNode inorderHelper(int start, int end) &#123; if(start &gt; end) return null; int mid = start + (end - start) / 2; TreeNode left = inorderHelper(start, mid - 1); TreeNode treenode = new TreeNode(node.val); treenode.left = left; node = node.next; TreeNode right = inorderHelper(mid + 1, end); treenode.right = right; return treenode; &#125;&#125; 2. Using in-order traversal template, simplerUpper two ways in reality using the feature of BST, which likes binary search. These two ways’ code looks similar to binary search template. There is another way using the template. 123456789101112131415161718192021222324252627public class Solution &#123; ListNode listNode; private TreeNode treeBuilder(int n) &#123; if (n == 0) return null; TreeNode treeNode = new TreeNode(0); treeNode.left = treeBuilder(n / 2); treeNode.val = listNode.val; listNode = listNode.next; treeNode.right = treeBuilder(n - n / 2 - 1); return treeNode; &#125; public TreeNode sortedListToBST(ListNode head) &#123; if (head == null) return null; int size = 1; ListNode curr = head; while (curr.next != null) &#123; size++; curr = curr.next; &#125; listNode = head; return treeBuilder(size); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2F2017%2F06%2F06%2FTrie%2F</url>
    <content type="text"><![CDATA[In computer science, a trie, also called digital tree and sometimes radix tree or prefix tree, is a kind of search tree—an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. Basic features: Root does not contains characters, other nodes only contain one character. From root to node, catenate all the characters one by one in the path, the string is the value of the node. The node may not have value. Every node has different node. Advantages: Looking up data in a trie is faster in the worst case, O(m) time (where m is the length of a search string), compared to an imperfect hash table. There are no collisions of different keys in a trie. A trie can provide an alphabetical ordering of the entries by key. Drawbacks: Tries can be slower in some cases than hash tables for looking up data, especially if the data is directly accessed on a hard disk drive or some other secondary storage device where the random-access time is high compared to main memory. Some keys, such as floating point numbers, can lead to long chains and prefixes that are not particularly meaningful. Some tries can require more space than a hash table, as memory may be allocated for each character in the search string, rather than a single chunk of memory for the whole entry, as in most hash tables. Insert OperationFrom the root, track the tree by characters in the word until the tail of the word. Build new nodes if necessary. Update the value of node which contains the last character of the word. (in the chart below, the nodes which contains value are painted red) Find OperationSame as insert operation, track the tree by characters in the word until the tail of the word. If the tail cannot be reached or there is no value of on the last node, return false There is a problem on LeetCode solved by trie: 211. Add and Search Word - Data structure design Design a data structure that supports the following two operations:void addWord(word)bool search(word)search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Acutally, if you are familiar with trie. It is so easy and no need to explain the solution. Here is my solution.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WordDictionary &#123; private class trieNode &#123; public trieNode[] children = new trieNode[26]; public String item = ""; &#125; private trieNode root; /** Initialize your data structure here. */ public WordDictionary() &#123; root = new trieNode(); &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; trieNode node = root; for (char c : word.toCharArray()) &#123; if (node.children[c - 'a'] == null) node.children[c - 'a'] = new trieNode(); node = node.children[c - 'a']; &#125; node.item = word; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; return match(word.toCharArray(), 0, root); &#125; private boolean match(char[] word, int k, trieNode node) &#123; if (k == word.length) return !node.item.equals(""); if (word[k] != '.') &#123; return node.children[word[k] - 'a'] != null &amp;&amp; match(word, k + 1, node.children[word[k] - 'a']); &#125; else &#123; for (int i = 0; i &lt; node.children.length; i++) if (node.children[i] != null &amp;&amp; match(word, k + 1, node.children[i])) return true; &#125; return false; &#125;&#125;/** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Gap]]></title>
    <url>%2F2017%2F05%2F29%2Fmaximum-gap%2F</url>
    <content type="text"><![CDATA[Pigeonhole principleIn mathematics, the pigeonhole principle states that if n items are put into m containers, with n &gt; m &gt; 0, then at least one container must contain more than one item. Bucket sort is a generalization of pigeonhole sort. It works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the most to least significant digit flavour. Bucket sort works as follows: Set up an array of initially empty “buckets”. Scatter: Go over the original array, putting each object in its bucket. Sort each non-empty bucket. Gather: Visit the buckets in order and put all elements back into the original array. Leetcode 164 Maximum Gap is a problem using bucket sort. Given an unsorted array, find the maximum difference between the successive elements in its sorted form.Try to solve it in linear time/space.Return 0 if the array contains less than 2 elements.You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. The straightforward solution is quicksort the array and then find the gap, but quicksort consumes O(NlogN) time. It reuqires O(N) time and O(N) space. That is a basic feature of bucket sort, so I choose Bucket Sort as the method. In this question, bucket sort contains several steps: 1.Find the bucket sizeThe easiest way to set the bucket size as 1. If the requirement is to sort and return the array, it is the fastest way (although consumes extra large space). In this question, set the bucket size as 1 will exceed time limit. So the 1st thing to do is to find the bucket size.123456789// get the max and min value of the arrayint min = num[0];int max = num[0];for (int i:num) &#123; min = Math.min(min, i); max = Math.max(max, i);&#125;// the minimum possibale gap, ceiling of the integer divisionint gap = (int)Math.ceil((double)(max - min)/(num.length - 1)); Suppose there are N elements in the array, the min value is min and the max value is max. Then the maximum gap will be no smaller than gap = ceiling((max - min) / (N - 1)). Set the bucket size to gap, that can promise the max gap is between two numbers in two different buckets rather than in the same bucket. 2.Put the numbers in buckets1234567891011int[] bucketsMIN = new int[num.length]; // store the min value in that bucketint[] bucketsMAX = new int[num.length]; // store the max value in that bucket// put numbers into bucketsfor (int i:num) &#123; if (i == min || i == max) continue; int idx = (i - min) / gap; // index of the right position in the buckets bucketsMIN[idx] = Math.min(i, bucketsMin[idx]); bucketsMAX[idx] = Math.max(i, bucketsMax[idx]);&#125; In every bucket, the array bucketsMin and bucketsMax saves the min and max elements in every bucket. The max gap is between two adjacent buckets and maxgap = bucketsMAX[i] - bucketsMIN[i-1]. 3.find the max gap12345678910111213// scan the buckets for the max gapint maxGap = Integer.MIN_VALUE;int previous = min;for (int i = 0; i &lt; num.length; i++) &#123; if (bucketsMin[i] == Integer.MAX_VALUE) // empty bucket continue; // min value minus the previous value is the current gap maxGap = Math.max(maxGap, bucketsMin[i] - previous); // update previous bucket value previous = bucketsMax[i];&#125; the completed solution is following:12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int maximumGap(int[] nums) &#123; if (nums == null || nums.length &lt; 2) return 0; int min = nums[0], max = nums[0]; for (int num : nums) &#123; min = Math.min(min, num); max = Math.max(max, num); &#125; if(max == min) return 0; int gap = (int)Math.ceil((double)(max - min) / (nums.length - 1)); int[] bucketsMin = new int[nums.length]; int[] bucketsMax = new int[nums.length]; Arrays.fill(bucketsMin, Integer.MAX_VALUE); Arrays.fill(bucketsMax, Integer.MIN_VALUE); for (int i : nums) &#123; int idx = (i - min) / gap; bucketsMin[idx] = Math.min(i, bucketsMin[idx]); bucketsMax[idx] = Math.max(i, bucketsMax[idx]); &#125; int maxgap = 0; int previous = min; for (int i = 0; i &lt; nums.length; i++) &#123; if(bucketsMin[i] == Integer.MAX_VALUE) continue; maxgap = Math.max(maxgap, bucketsMin[i] - previous); previous = bucketsMax[i]; &#125; return maxgap; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dutch National Flag]]></title>
    <url>%2F2017%2F05%2F24%2FDutch-National-Flag%2F</url>
    <content type="text"><![CDATA[Dijkstra used the Dutch National Flag Problem as a structured programming exercise in program derivation and program proof. Given N objects coloured red, white or blue, sort them so that objects of the same colour are adjacent, with the colours in the order red, white and blue. Similar Problem on LeetCode : 75. Sort ColorsGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem.click to show follow up. Follow up:A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.Could you come up with an one-pass algorithm using only constant space? 1. Two-pass solution based on bucket sortObviously, this is a sort problem and it only contains 3 kinds of elements: red, white and blue, which reminds me of bucket sort. Use 3 integers to record the number of 3 colors in the 1st pass, then sort the array in the second pass. 123456789101112131415public class Solution &#123; public void sortColors(int[] A) &#123; int numRed = 0, numWhite = 0, numBlue = 0; for (int i = 0; i &lt; A.length; i++) &#123; if (A[i] == 0) numRed++; else if (A[i] == 1) numWhite++; else numBlue++; &#125; for (int i = 0; i &lt; A.length; i++) &#123; if (i &lt; numRed) A[i] = 0; else if (i &lt; numRed + numWhite) A[i] = 1; else A[i] = 2; &#125; &#125; &#125; 2. One-pass solution with 2 pointers in two waysAs follow-up requires, two-pass solution is not efficient enough. There should be one way to find elements and sort array at the same time. swap is used in this solution. Use two pointers end0 and head2 to record the end of 0 and the head of 2 during the process, respectively. At the beginning, end0 = 0, head2 = n - 1, where n is the length of array; When traverse all the elements, if it is 0, swap it with end0; If it is ‘2’, swap it with head2. Attention: if the element is 2, you cannot just swap it with head2 and go on, it may possible that the element at head2 is 0, so it is important to do extra check before moving on. On the contrary, the swap with end0 do not need extra check because element at end0 is sorted.12345678910111213141516171819public class Solution &#123; public void sortColors(int[] nums) &#123; int n = nums.length; int end0 = 0, head2 = n - 1, i = 0; while(i &lt;= head2) &#123; if(nums[i] == 0) swap(nums, end0++, i++); else if(nums[i] == 2) swap(nums, head2--, i); else i++; &#125; &#125; private void swap(int[] nums, int i1, int i2) &#123; int tmp = nums[i1]; nums[i1] = nums[i2]; nums[i2] = tmp; &#125;&#125; 3. One-pass solution with 3 pointers in one wayThere is one more easy way to solve this problem. The pointers only move in one way, and no swap is needed. All 3 pointers start from the head of array, record the end of 0,1,2.123456789101112131415161718public class Solution&#123; public void sortColors(int A[], int n) &#123; int n0 = -1, n1 = -1, n2 = -1; for (int i = 0; i &lt; n; ++i) &#123; if (A[i] == 0) &#123; A[++n2] = 2; A[++n1] = 1; A[++n0] = 0; &#125; else if (A[i] == 1) &#123; A[++n2] = 2; A[++n1] = 1; &#125; else if (A[i] == 2) &#123; A[++n2] = 2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2 and NodeJS, the practical guide: Introduction]]></title>
    <url>%2F2017%2F05%2F20%2FAngular-2-and-NodeJS-the-practical-guide-Introduction%2F</url>
    <content type="text"><![CDATA[1. NodeJSNodeJS is a server-side language based on JavaScript. Its function likes PHP, Ruby. Its function includes handle requests parse data generate &amp; send responses file operations One of the most popular framework of NodeJS is Express, an superset to NodeJS, which includes many common test to make you focus on the core things. 2. Angular 2Angular 2 is running on Browser, provides reactive experience. No need for send request and wait for response, every thing of Angular 2 happens instantly. Angular 2 is a superset to javascript.Angular 2 has some figures:1.Single page It runs one single page and updates parts of the page which need updating 2.Updates DOMIt updates the DOM to read render parts of the page which need to be updated 3.Handles routing of visual partsit will not use server for the routing. Instead, every thing works at the front end to load things faster. 4.Very reactive user experience 3. How NodeJS and Angular 2 work together When using a server-side only application, the client do not need to do any thing, just get the resource from the server. But obviously, every change of the page should have a request to server, and take which slow down the reaction of the application. Single page application can do the rendering on the client, server just need to send data to client and client will do the rendering and generate the page itself. 4. Setting up project Go to nodejs.org to download and install the latest version nodejs Open the NodeJS project and use terminal to navigate to the project folder. Use npm install to install the dependencies. Use npm run build, and keep it running, when something updated, it can update it in real time Open a new terminal ‘npm start’ to start the project, use web server to visit localhost:3000 to see the web.]]></content>
      <categories>
        <category>Full Stack</category>
      </categories>
      <tags>
        <tag>front end</tag>
        <tag>Angular 2</tag>
        <tag>NodeJS</tag>
        <tag>Udemy</tag>
        <tag>full stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Princeton Algorithm I: Elementary Symbol Tables]]></title>
    <url>%2F2017%2F05%2F19%2FPrinceton-Algorithm-I-Elementary-Symbol-Tables%2F</url>
    <content type="text"><![CDATA[1. API-What is the meaning of symbol tables?-Associate values to each key. To be more specific, to implements Key-Value pair abstraction. Key-Value pair abstraction Insert a value with specified key Given a key, search for the corresbonding value Ex. DNS lookup Insert URL with specified IP address Given URL, find corresponding IP address Some conventions Values are not null Method get() returns null if the key not present Method put() overwrites old value with new valuea Equality testAll Java classes inherit a method equals. To design equals, some standard recipe are following: Optimization for reference equality Check against null Check that to objects are of the same type and cast Compare each significant field: if field is a primitive type, use == if field is an object, use object.equals() if field is an array, apply to each entry (or Arrays.equals(a,b) but not a.equals(b)) Ex. Input a file, contains many words, output the word with max freqency123456789101112131415161718192021public class FrequencyCounter&#123; public static void main(String[] args) &#123; int minlen = Integer.parseInt(args[0]); ST&lt;String, Integer&gt; st = new ST&lt;String,Integer&gt;(); while (!StdIn.isEmpty()) &#123; //read the string and update freqency String word = StdIn.readString(); if (word.length() &lt; minlen) continue; //ignore short strings if (!st.contains(word)) st.put(word, 1); else st.put(word, st.get(word) + 1); &#125; String max = ""; st.put(max, 0); for (String word : st.keys()) if (st.get(word) &gt; st.get(max)) max = word; StdOut.println(max + " " + st.get(max)); //Print the string with max freq &#125;&#125; 2. Elementary ST implementation2.1 Sequential search in a linked listData structureMaintain an (unordered) linked list of key-value pairs.SearchScan through all keys until find a match.InsertScan through all keys until find a match; if no match add to front. 2.2 Binary Search in an ordered arrayData structureMaintain an ordered array of key-value pairs.SearchBinary SearchInsertNeed to shift all greater keys over. Important function for binary search: How many keys &lt; k ? 12345678910111213141516171819202122public Value get(Key key)&#123; if (isEmpty()) return null; int i = rank(key); if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) return vals[i]; else return null;&#125;//return the number of keys &lt; kprivate int rank(Key key)&#123; int lo = 0, hi = N-1; while (lo &lt;= hi) //Binary search &#123; int mid = lo + (hi - lo) / 2; int cmp = key.compareTo(keys[mid]); if (cmp &lt; 0) hi = mid - 1; else if (cmp &gt; 0) lo = mid + 1; else if (cmp == 0) return mid; &#125; return lo; &#125; The Summary of two ways is listed Obveresly, these two ways are not efficient enough, some optimization is still needed. Which will be discussed next. 3. Ordered OperationNormally, Ordered symbol table should have the following API 123456789101112131415161718192021public class ST&lt;Key extends Comparable&lt;Key&gt;, Value&gt;&#123; ST(); // create an ordered symbol table void put(Key key, Value val); //put key-value pair into the table (remove key from table if value is null) Value get(Key key); //value paired with key (null if key is absent) void delete(Key key); //remove key (and its value) from table boolean contains(Key key); //is there a value paired with key? boolean isEmpty(); //is the table empty? int size(); //number of key-value pairs Key min(); //smallest key Key max(); //largest key Key floor(Key key); //largest key less than or equal to key Key ceiling(Key key); //smallest key greater than or equal to key int rank(Key key); //number of keys less than key Key select(int k); //key of rank k void deleteMin(); //delete smallest key void deleteMax(); //delete largest key int size(Key lo, Key hi); //number of keys in [lo..hi] Iterable&lt;Key&gt; keys(Key lo, Key hi); //keys in [lo..hi], in sorted order Iterable&lt;Key&gt; keys(); //all keys in the table, in sorted order&#125;]]></content>
      <categories>
        <category>Princeton Algorithm I</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>princeton</tag>
        <tag>open course</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[New Blog, New Life]]></title>
    <url>%2F2017%2F05%2F15%2FNew-Blog-New-Life%2F</url>
    <content type="text"><![CDATA[HELLO THERE,This is my blog, posted on my own github.I created it by Hexo. Many themes tried, and Next is selected. Why I build this blog?I build this blog intending to write something for my coding life. I just followed a web course about algorithm and found that it was so inefficient to work out algorithm problems without discussion. I should make some conclusion on it to intensify the memory of these knowledge. At the same time, this blog can help me to : save my junk writing English learn about how to use my new Macbook Pro learn about how to use git to manage my project learn about Markdown, a language to write blog, which I am using to type this word What will I do on this blog? Conclusions about algorithm, problem oriented Some of my projects details Maybe some diary? Maybe some thoughts on movies, series or music A request to whom read this blogWell…… I am a little bit LAZY. So if you find that there is long time after the last article, please kindly remind me to write something. In the endAs all the coders do at the beginng… Hello World!]]></content>
      <categories>
        <category>My Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>